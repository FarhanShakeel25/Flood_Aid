# Flood Aid - Deployment Guide

## Overview

This guide covers deploying the Flood Aid application to production environments. It includes instructions for deploying to Render (backend) and Vercel (frontend).

**Current Production URLs:**
- Frontend: https://flood-aid-94zg.vercel.app
- Backend API: https://floodaid-api.onrender.com

---

## Table of Contents

1. [Pre-Deployment Checklist](#pre-deployment-checklist)
2. [Backend Deployment (Render)](#backend-deployment-render)
3. [Frontend Deployment (Vercel)](#frontend-deployment-vercel)
4. [Database Deployment (PostgreSQL)](#database-deployment-postgresql)
5. [Environment Configuration](#environment-configuration)
6. [Health Checks & Monitoring](#health-checks--monitoring)
7. [Rollback Procedures](#rollback-procedures)
8. [Troubleshooting](#troubleshooting)

---

## Pre-Deployment Checklist

### Code Quality

- [ ] All unit tests passing locally: `dotnet test` & `npm test`
- [ ] No console errors in development build
- [ ] Code review completed and approved
- [ ] Git branch merged to main/production
- [ ] All secrets removed from code (use environment variables)

### Documentation

- [ ] README updated with new features
- [ ] API documentation updated
- [ ] Breaking changes documented
- [ ] Migration guide provided if needed

### Testing

- [ ] Smoke tests passing on staging
- [ ] Payment testing (Stripe test mode) successful
- [ ] Email confirmations working
- [ ] Admin authentication tested
- [ ] Rate limiting verified

### Security

- [ ] All credentials use environment variables
- [ ] JWT secret key is strong (32+ chars)
- [ ] HTTPS enforced everywhere
- [ ] Database password is strong
- [ ] API keys rotated if exposed

### Performance

- [ ] Database queries optimized
- [ ] Frontend bundle size acceptable
- [ ] API response times < 500ms
- [ ] Database backups configured
- [ ] CDN caching configured (if applicable)

---

## Backend Deployment (Render)

### Prerequisites

- GitHub account with repository access
- Render account (https://render.com)
- PostgreSQL database configured
- Environment variables documented

### Automated Deployment (Recommended)

Render auto-deploys on push to main branch.

#### Initial Setup

1. **Connect GitHub to Render**:
   - Log in to Render dashboard
   - Click "New +" → "Web Service"
   - Select "Deploy an existing repository"
   - Choose your GitHub repository
   - Click "Connect"

2. **Configure Service**:
   - **Name**: `floodaid-api`
   - **Environment**: `Docker`
   - **Region**: `Oregon` (or closest to users)
   - **Branch**: `main`
   - **Build Command**: 
     ```bash
     cd backend/FloodAid.Api && dotnet publish -c Release -o out
     ```
   - **Start Command**:
     ```bash
     dotnet /app/out/FloodAid.Api.dll
     ```

3. **Set Environment Variables**:
   ```
   ASPNETCORE_ENVIRONMENT=Production
   DATABASE_URL=postgresql://user:pass@host:5432/floodaid
   JWT_SECRET=your-32-character-secret-key
   STRIPE_API_KEY=sk_live_...
   BREVO_API_KEY=your-brevo-key
   FRONTEND_URL=https://flood-aid-94zg.vercel.app
   ```

4. **Configure Networking**:
   - **Public URL**: Auto-generated by Render
   - **HTTPS**: Automatically enabled (Render provides SSL)
   - **CORS**: Backend configured to allow frontend URL

5. **Deploy**:
   - Click "Create Web Service"
   - Render starts build and deployment
   - Monitor logs in Render dashboard

#### View Deployment Logs

```bash
# In Render dashboard:
# Services → floodaid-api → Logs
# Real-time logs visible in terminal
```

### Manual Deployment (If Needed)

```bash
# 1. Build Docker image locally
docker build -t floodaid-api:latest .

# 2. Tag for Render registry
docker tag floodaid-api:latest render.onrender.com/floodaid-api:latest

# 3. Push to registry
docker push render.onrender.com/floodaid-api:latest

# 4. Trigger deployment in Render dashboard
```

### Database Migration on Production

```bash
# Run migrations automatically during deployment
# via environment variable:
RUN_MIGRATIONS=true

# Or manually via SSH:
# Connect to Render instance and run:
# cd /app && dotnet ef database update --configuration Release
```

### Post-Deployment Verification

```bash
# 1. Check health endpoint
curl https://floodaid-api.onrender.com/health
# Expected: {"status":"healthy"}

# 2. Check Swagger docs
curl https://floodaid-api.onrender.com/scalar/v1

# 3. Test create session endpoint
curl -X POST https://floodaid-api.onrender.com/api/donation/create-session \
  -H "Content-Type: application/json" \
  -d '{"name":"Test","email":"test@example.com","amount":100}'
```

---

## Frontend Deployment (Vercel)

### Prerequisites

- Vercel account (https://vercel.com)
- GitHub repository connected
- Environment variables configured

### Automated Deployment (Recommended)

Vercel auto-deploys on push to main branch.

#### Initial Setup

1. **Import Project to Vercel**:
   - Visit https://vercel.com/new
   - Select "Import Git Repository"
   - Choose your Flood_Aid repository
   - Click "Import"

2. **Configure Build**:
   - **Framework**: `Vite`
   - **Root Directory**: `./frontend`
   - **Build Command**: `npm run build`
   - **Output Directory**: `dist`

3. **Set Environment Variables**:
   - In Vercel dashboard → Settings → Environment Variables
   ```
   VITE_STRIPE_PUBLIC_KEY=pk_live_... (or pk_test_ for staging)
   VITE_API_URL=https://floodaid-api.onrender.com
   VITE_ENVIRONMENT=production
   ```

4. **Deploy**:
   - Click "Deploy"
   - Vercel starts build
   - Deployment completes in 2-5 minutes

#### View Deployment Logs

```
Vercel Dashboard → Deployments → Click latest → Logs
```

### Environment Variables by Stage

| Variable | Development | Staging | Production |
| --- | --- | --- | --- |
| VITE_API_URL | http://localhost:5273 | https://staging-api.onrender.com | https://floodaid-api.onrender.com |
| VITE_STRIPE_PUBLIC_KEY | pk_test_... | pk_test_... | pk_live_... |

### Post-Deployment Verification

1. **Visit Frontend**:
   - https://flood-aid-94zg.vercel.app
   - Verify no console errors (F12 → Console)

2. **Test Navigation**:
   - [ ] Home page loads
   - [ ] Donation form loads
   - [ ] Navigation works

3. **Test API Integration**:
   - [ ] Create donation attempt calls backend
   - [ ] Response displayed correctly
   - [ ] No CORS errors

---

## Database Deployment (PostgreSQL)

### Cloud Provider Options

#### Option 1: Render PostgreSQL (Recommended for this project)

1. **Create Database**:
   - Render Dashboard → New → PostgreSQL
   - **Name**: `floodaid-db`
   - **Region**: Same as backend service
   - **PostgreSQL Version**: 14+

2. **Configure**:
   - **Username**: `floodaid_prod`
   - **Password**: Auto-generated (save securely)
   - Note the `DATABASE_URL` provided by Render

3. **Use Connection String**:
   - Copy `DATABASE_URL` from Render
   - Add to backend environment variables

#### Option 2: AWS RDS

1. **Create RDS Instance**:
   - AWS Console → RDS → Create Database
   - **Engine**: PostgreSQL
   - **Version**: 14.0+
   - **DB Instance Class**: db.t3.micro (free tier)

2. **Configure Security**:
   - **VPC**: Select appropriate VPC
   - **Public Accessibility**: Yes (if external access needed)
   - **Security Group**: Allow port 5432

3. **Get Connection String**:
   - Format: `postgresql://user:password@endpoint:5432/dbname`

#### Option 3: DigitalOcean Managed Database

1. **Create Database**:
   - DigitalOcean → Databases → Create Database Cluster
   - **Engine**: PostgreSQL
   - **Version**: 14.0+
   - **Size**: Starter plan

2. **Configure Connection**:
   - Get connection string from DigitalOcean dashboard

### Initial Database Setup

```bash
# 1. Apply migrations on production database
cd backend/FloodAid.Api
dotnet ef database update --configuration Release --connection "your-production-connection-string"

# 2. Seed initial admin (if needed)
# Admin data seeded automatically by SeedData.cs during migration

# 3. Verify tables created
psql "your-production-connection-string"
\dt  # List all tables
SELECT COUNT(*) FROM admin_users;  # Should show admin created
\q
```

### Backup Strategy

#### Automated Backups

**Render**: Automatic daily backups included

**AWS RDS**: Configure automated backups
```
AWS Console → RDS → Databases → floodaid-db → Backups
- Backup Retention Period: 30 days
- Backup Window: 03:00 UTC
```

#### Manual Backup

```bash
# Create backup
pg_dump "postgresql://user:pass@host:5432/floodaid" > backup_$(date +%Y%m%d).sql

# Restore from backup
psql "postgresql://user:pass@host:5432/floodaid" < backup_20251231.sql
```

#### Backup Storage

- Store backups in cloud storage (AWS S3, Google Cloud Storage)
- Automate via cron job or cloud function
- Retain at least 30 days of backups

### Database Monitoring

#### Connection Pool Monitoring

```sql
-- Check active connections
SELECT datname, count(*) FROM pg_stat_activity GROUP BY datname;

-- Check connection limits
SHOW max_connections;

-- Set for production
ALTER SYSTEM SET max_connections = 100;
```

#### Performance Monitoring

```sql
-- Slow queries
SELECT query, calls, total_time, mean_time 
FROM pg_stat_statements 
ORDER BY mean_time DESC LIMIT 10;

-- Missing indexes
SELECT schemaname, tablename 
FROM pg_tables 
WHERE schemaname = 'public';
```

---

## Environment Configuration

### Backend Environment Variables

Create `.env` file or set in deployment platform:

```bash
# ASP.NET Configuration
ASPNETCORE_ENVIRONMENT=Production
ASPNETCORE_URLS=https://+:443
ASPNETCORE_Kestrel__Certificates__Default__Path=/app/certs/cert.pem
ASPNETCORE_Kestrel__Certificates__Default__KeyPath=/app/certs/key.pem

# Database
DATABASE_URL=postgresql://user:password@host:5432/floodaid

# JWT Authentication
JWT_SECRET=your-super-secret-key-min-32-characters-long!
JWT_ISSUER=FloodAid.Api
JWT_AUDIENCE=FloodAid.Frontend
JWT_EXPIRY_MINUTES=1440

# Stripe (LIVE KEYS IN PRODUCTION!)
STRIPE_API_KEY=sk_live_YOUR_STRIPE_LIVE_SECRET_KEY
STRIPE_PUBLIC_KEY=pk_live_YOUR_STRIPE_LIVE_PUBLIC_KEY

# Brevo Email Service
BREVO_API_KEY=your-brevo-api-key

# Logging
LOGGING_LEVEL=Information
LOG_FILE=/var/log/floodaid/api.log

# CORS
FRONTEND_URL=https://flood-aid-94zg.vercel.app

# Cache (optional Redis)
REDIS_CONNECTION_STRING=localhost:6379
USE_REDIS=false
```

### Frontend Environment Variables

Create `.env.production` or configure in Vercel:

```bash
# API Configuration
VITE_API_URL=https://floodaid-api.onrender.com

# Stripe (LIVE KEYS!)
VITE_STRIPE_PUBLIC_KEY=pk_live_YOUR_LIVE_STRIPE_KEY

# Environment
VITE_ENVIRONMENT=production

# Analytics (optional)
VITE_GA_ID=your-google-analytics-id
```

### Secrets Management

**Never commit secrets to Git!**

#### Using Git Ignore
```bash
# .gitignore
.env
.env.local
.env.*.local
appsettings.Production.json
```

#### Using Secure Vaults

**Backend (ASP.NET)**:
```bash
# Local secrets (development only)
dotnet user-secrets set "JwtSettings:SecretKey" "your-secret"

# Production: Use environment variables or Azure Key Vault
```

**Frontend (React)**:
```bash
# Never store secrets in frontend!
# VITE_STRIPE_PUBLIC_KEY is safe (public key)
# All sensitive operations done server-side
```

---

## Health Checks & Monitoring

### Render Health Checks

Render monitors backend service health:

```
Render Dashboard → Services → floodaid-api → Health
```

Configure custom health check:
```json
{
  "health_check": {
    "path": "/health",
    "protocol": "https",
    "interval_seconds": 30,
    "timeout_seconds": 10
}
```

### Monitoring with Uptime Robot

1. **Create Monitor**:
   - Visit https://uptimerobot.com
   - Click "Add New Monitor"
   - **Type**: HTTPS
   - **URL**: https://floodaid-api.onrender.com/health
   - **Interval**: 5 minutes
   - **Alert Contacts**: Your email

2. **Notifications**:
   - Get alerts if service down
   - Uptime report available monthly

### Application Monitoring (Optional)

**Sentry (Error Tracking)**:
```bash
# Install Sentry package
dotnet add package Sentry.AspNetCore

# Configure in Program.cs
builder.WebHost.UseSentry("your-sentry-dsn");
```

Visit dashboard to view errors: https://sentry.io

**New Relic (Performance Monitoring)**:
- Register at https://newrelic.com
- Install .NET agent
- Monitor response times, database queries, errors

---

## Rollback Procedures

### Backend Rollback (Render)

1. **View Deployment History**:
   ```
   Render Dashboard → Services → floodaid-api → Deployments
   ```

2. **Redeploy Previous Version**:
   - Click previous deployment
   - Click "Redeploy"
   - Confirm

3. **Manual Rollback via Git**:
   ```bash
   git revert HEAD  # Create new commit reverting changes
   git push origin main  # Render auto-deploys
   ```

### Frontend Rollback (Vercel)

1. **View Deployments**:
   ```
   Vercel Dashboard → Deployments
   ```

2. **Promote Previous Deployment**:
   - Click previous deployment
   - Click "Promote to Production"

### Database Rollback

```bash
# If migrations fail, revert
cd backend/FloodAid.Api
dotnet ef database update PreviousMigrationName

# Or restore from backup
pg_restore "postgresql://connection-string" < backup_file.sql
```

### Communication

When rollback occurs:
1. Notify team via Slack/email
2. Document reason for rollback
3. Post-mortem analysis
4. Prevent similar issues

---

## Troubleshooting

### Issue: 502 Bad Gateway

**Symptoms**: Backend returning 502 error

**Causes & Solutions**:
```bash
# 1. Check if service is running
curl https://floodaid-api.onrender.com/health

# 2. Check service logs
# Render Dashboard → Services → Logs

# 3. Check database connection
# Verify DATABASE_URL in environment variables

# 4. Restart service
# Render Dashboard → Services → Restart
```

### Issue: CORS Error in Browser

**Symptoms**: 
```
Access to XMLHttpRequest blocked by CORS policy
```

**Solutions**:
```bash
# 1. Check CORS configuration in Program.cs
# Verify Frontend:Url matches actual frontend URL

# 2. Check backend is running
curl -H "Origin: https://flood-aid-94zg.vercel.app" \
     -H "Access-Control-Request-Method: POST" \
     https://floodaid-api.onrender.com/api/donation/create-session

# 3. Backend logs
# Check for CORS errors in Render logs
```

### Issue: Database Connection Timeout

**Symptoms**:
```
Npgsql.NpgsqlException: Timeout during opening of connection
```

**Solutions**:
```bash
# 1. Test connection string
psql "postgresql://user:pass@host:5432/floodaid"

# 2. Check database is accessible
# RDS/Render dashboard → connectivity

# 3. Check connection pool settings
# Increase connection timeout in appsettings.json
"ConnectionStrings": {
  "DefaultConnection": "...;Connection Timeout=30"
}

# 4. Check firewall rules
# Ensure port 5432 open and IP whitelisted
```

### Issue: Stripe Payment Failing

**Symptoms**: 
```
Payment session creation fails
```

**Solutions**:
```bash
# 1. Verify API keys
# Check STRIPE_API_KEY is sk_live_ (production)
# Check STRIPE_PUBLIC_KEY is pk_live_ (production)

# 2. Check Stripe account
# Log in to Stripe dashboard
# Verify account is in production mode
# Check for any restrictions

# 3. Check webhook configuration
# Render → Services → floodaid-api → Environment
# Verify STRIPE_WEBHOOK_SECRET is set
```

### Issue: Emails Not Sending

**Symptoms**: 
```
Email confirmation not received
```

**Solutions**:
```bash
# 1. Check Brevo API key
# Verify BREVO_API_KEY in environment variables

# 2. Check email configuration
# Brevo dashboard → Email → Verify sender

# 3. Check email logs
# Brevo dashboard → Reports → Sent emails

# 4. Test email manually
curl -X POST https://api.brevo.com/v3/smtp/email \
  -H "api-key: YOUR_BREVO_KEY" \
  -d '{...}'
```

### Issue: Frontend Not Loading

**Symptoms**: 
```
Vercel showing error or blank page
```

**Solutions**:
```bash
# 1. Check build logs
Vercel → Deployments → Click deployment → Logs

# 2. Check environment variables
Vercel → Settings → Environment Variables
Verify VITE_API_URL and VITE_STRIPE_PUBLIC_KEY

# 3. Clear Vercel cache
Vercel → Settings → Git → Redeploy

# 4. Test build locally
cd frontend
npm install
npm run build
npm run preview
```

---

## Performance Optimization

### Backend Optimization

```csharp
// Program.cs

// Enable response compression
builder.Services.AddResponseCompression(options =>
{
    options.EnableForHttps = true;
    options.Providers.Add<GzipCompressionProvider>();
});

// Add caching headers
app.UseHsts();  // HTTP Strict Transport Security

// Enable async I/O
// Already using async/await throughout
```

### Frontend Optimization

**Vercel Edge Functions** (cache common requests):
```
Vercel → Settings → Edge Functions
Configure caching rules for API responses
```

**CDN Caching**:
- Vercel provides free global CDN
- Static assets cached indefinitely
- API responses cached based on headers

---

## Incident Response Plan

### When Something Goes Down

1. **Assess Impact**: Is it frontend, backend, or database?
2. **Alert Team**: Notify stakeholders
3. **Initial Response**: Check monitoring dashboards
4. **Triage**: Determine severity (P1=critical, P4=minor)
5. **Implement Fix**:
   - Check logs for errors
   - Revert recent changes if needed
   - Restart services if hung
6. **Verify**: Test affected functionality
7. **Communicate**: Update status page
8. **Post-Mortem**: Document incident and prevention

### Escalation Contacts

- **On-Call**: [Developer Name/Number]
- **Manager**: [Manager Name/Number]
- **Infrastructure**: [DevOps Name/Number]

---

## Security Checklist

- [ ] HTTPS enforced everywhere
- [ ] JWT secret is strong (32+ characters)
- [ ] No hardcoded credentials in code
- [ ] Environment variables for all secrets
- [ ] Database password is strong
- [ ] API rate limiting enabled
- [ ] CORS properly configured
- [ ] Stripe using LIVE keys (not test)
- [ ] Database backups encrypted
- [ ] Regular security updates applied

---

**Last Updated**: December 31, 2025  
**Version**: 1.0  
**Status**: Production Ready
